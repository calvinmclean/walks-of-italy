// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: latest_availabilities.sql

package db

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addLatestAvailability = `-- name: AddLatestAvailability :exec
INSERT INTO
    latest_availabilities (
        tour_uuid,
        recorded_at,
        availability_date,
        raw_data
    )
VALUES
    (?, CURRENT_TIMESTAMP, ?, ?)
`

type AddLatestAvailabilityParams struct {
	TourUuid         uuid.UUID
	AvailabilityDate time.Time
	RawData          string
}

func (q *Queries) AddLatestAvailability(ctx context.Context, arg AddLatestAvailabilityParams) error {
	_, err := q.db.ExecContext(ctx, addLatestAvailability, arg.TourUuid, arg.AvailabilityDate, arg.RawData)
	return err
}

const getAllLatestAvailabilities = `-- name: GetAllLatestAvailabilities :many
SELECT
    t.name,
    t.link,
    t.api_url,
    t.uuid,
    la.recorded_at,
    la.availability_date,
    la.raw_data
FROM
    latest_availabilities la
    JOIN tours t ON t.uuid = la.tour_uuid
WHERE
    la.recorded_at = (
        SELECT
            MAX(recorded_at)
        FROM
            latest_availabilities
        WHERE
            tour_uuid = t.uuid
    )
`

type GetAllLatestAvailabilitiesRow struct {
	Name             string
	Link             string
	ApiUrl           string
	Uuid             uuid.UUID
	RecordedAt       time.Time
	AvailabilityDate time.Time
	RawData          string
}

func (q *Queries) GetAllLatestAvailabilities(ctx context.Context) ([]GetAllLatestAvailabilitiesRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllLatestAvailabilities)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllLatestAvailabilitiesRow
	for rows.Next() {
		var i GetAllLatestAvailabilitiesRow
		if err := rows.Scan(
			&i.Name,
			&i.Link,
			&i.ApiUrl,
			&i.Uuid,
			&i.RecordedAt,
			&i.AvailabilityDate,
			&i.RawData,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestAvailability = `-- name: GetLatestAvailability :one
SELECT
    tour_uuid,
    recorded_at,
    availability_date,
    raw_data
FROM
    latest_availabilities
WHERE
    tour_uuid = ?
ORDER BY
    availability_date DESC
LIMIT
    1
`

func (q *Queries) GetLatestAvailability(ctx context.Context, tourUuid uuid.UUID) (LatestAvailability, error) {
	row := q.db.QueryRowContext(ctx, getLatestAvailability, tourUuid)
	var i LatestAvailability
	err := row.Scan(
		&i.TourUuid,
		&i.RecordedAt,
		&i.AvailabilityDate,
		&i.RawData,
	)
	return i, err
}
